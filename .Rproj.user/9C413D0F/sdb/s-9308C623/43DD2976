{
    "collab_server" : "",
    "contents" : "library(dplyr)\n\n\n\nalignment <- function(timePassSecond,BBE_time,seabirdIndex,bbeIndex){\n\tnewSeabirdTime <- BBE_time[bbeIndex]\n\ttimeAdjust <- (seq(1:length(BBE_time))-seabirdIndex)*0.5\n\tnewSeabirdTime <- newSeabirdTime+timeAdjust\n\treturn(newSeabirdTime)\n}\n\n\npreprocessing <- function(Triaxus){\n\tseabirdIndex <- Triaxus@SeabirdAnchorIndex\n\tbbeIndex <- Triaxus@BBEAnchorIndex\n\t\n\tTriaxus@rawData <- initProcess(Triaxus@rawData)\n\tBBE_name <- Triaxus@config$BBE_name\n\tSeabird_name <- Triaxus@config$Seabird_name\n\n\tgeoData <- Triaxus@rawData[,c(\"latitude\",\"longitude\",\"distance\",\"UTC\")]\n\tSeabird_data <- Triaxus@rawData[,c(Seabird_name,\"Seabird_depth\")]\n\tLOPC_data <- Triaxus@rawData[,Triaxus@config$LOPC_name]\n\tTriaxus@cleanData <- cbind(geoData,Seabird_data,LOPC_data)\n\t\n\tn <- nrow(Triaxus@cleanData)\n\tTriaxus@cleanData[,BBE_name] <- NA\n\n\tif(seabirdIndex>0 & bbeIndex>0){\n\t\tprint(\"Aligning BBE Data\")\n\t\tBBE_data <- Triaxus@rawData[,c(BBE_name)]\n\t\tBBE_time <- strptime(Triaxus@rawData$BBE_time,format=\"%Y-%m-%d-%H-%M-%S\")\n\t\tnewSeabirdTime <- alignment(Triaxus@rawData$timePassSecond,BBE_time,seabirdIndex,bbeIndex)\n\t\tTriaxus@cleanData[,BBE_name] <- linearAlignment(newSeabirdTime,BBE_time,BBE_data,rule=1)\n\t}\n\t\n\t# if(length())\n\t# startIndex <- ifelse(Triaxus@Seabird_cutoff[1]<1,1,Triaxus@Seabird_cutoff[1])\n\t# endIndex <- ifelse(Triaxus@Seabird_cutoff[2]<1,n,Triaxus@Seabird_cutoff[2])\n\n\t# Triaxus@cleanData <- Triaxus@cleanData[startIndex:endIndex,]\n\tTriaxus@cleanData <- Triaxus@cleanData[Triaxus@Seabird_cutoff,]\n\t\n\tSeabird_separation <- depth_separation(Triaxus@cleanData$Seabird_depth)\n\tSeabird_nodes <- Seabird_separation[[2]]\n\n\tfinalStartNodes <- Seabird_nodes[2]\n\tfinalEndNodes <- Seabird_nodes[length(Seabird_nodes)-1]\n\tTriaxus@cleanData$direction <- Seabird_separation[[1]]\n\tTriaxus@cleanData$depth <- Triaxus@cleanData$Seabird_depth\n\t\n\tTriaxus@cleanData <- Triaxus@cleanData[finalStartNodes:finalEndNodes,]\n\n\t# Adding salinity and density estimation.\n\ttmpData <- Triaxus@cleanData[,c(\"latitude\",\"longitude\",\"pressure\",\"conductivity\")]\n\ttmpData$temperature <- Triaxus@cleanData$Seabird_temperature\n\tdensityData <- cal_density(tmpData)\n\tTriaxus@cleanData <- cbind(Triaxus@cleanData,densityData)\n\n\t\n\tTriaxus@numCycle <- (length(Seabird_separation[[2]])-1)/2-1\n\treturn(Triaxus)\n}\n\n\n\ninitProcess <- function(dataSet){\n\t# dataSet <- na.omit(dataSet)\n\tdataSet <- dplyr::select(dataSet,-c(latitude,longitude,ShpSpd_Cmputd,scan.count,DO.optode,optode.T))\n\tdataSet <- dplyr::rename(dataSet,BBE_depth=depth.1,Seabird_depth=depth,Seabird_temperature=temp,\n\t\tBBE_temperature=temp.1,distance=Distance,DO=DO.43.mg.L,DOsat=DO43...sat,latitude=DDLat,longitude=DDLong,conductivity = cond)\n\t\n\tif(\"Zdens\" %in% names(dataSet)){\n\t\tdataSet$Zdens <- as.numeric(as.character(dataSet$Zdens))\n\t}\n\n\tif(\"Zug\" %in% names(dataSet)){\n\t\tdataSet$Zug <- as.numeric(as.character(dataSet$Zug))\n\t}\n\treturn(dataSet)\n}\n\n\n\nlinearAlignment <- function(targetIndex,sourceIndex,sourceDataSet,rule=2){\n\ttargetDataSet <- list()\n\tfor(var in names(sourceDataSet))\n\t\ttargetDataSet[[var]] <- approx(x=sourceIndex,y=sourceDataSet[,var],xout=targetIndex,rule=rule)$y\n\n\treturn(data.frame(targetDataSet))\n}\n\n\n\nrepeatLast <- function(x){\n\tn <- length(x)\n\treturn(c(x,x[n]))\n}\n\ndepth_separation <- function(depth,...){\n\tn <- length(depth)\n\tdepth_smooth <- -smooth.spline(depth,spar=0.01)$y\n\tN <- length(depth_smooth)\n\tif(N!=n){\n\t\twarning(\"Spline generates different number of data\")\n\t}\n\n\tdiff_D <- diff(depth_smooth)\n\tD1 <- diff_D[1:(N-1)]\n    D2 <- diff_D[2:N]\n\n    transition_points <- c(1,(which(D1*D2<0)+1),N)\n\n    directionVector <- c()\n    previousNode <- 1\n\n    for(i in transition_points[-1]){\n    \tif(depth_smooth[i]>depth_smooth[i-1]){# this is a peak point\n    \t\tdirectionVector <- c(directionVector,rep(1,i-previousNode))\n    \t}\n    \telse{# this is a valley point\n    \t\tdirectionVector <- c(directionVector,rep(-1,i-previousNode))\n    \t}\n    \tpreviousNode <- i\n    }\n    directionVector <- repeatLast(directionVector)\n    return(list(directionVector,transition_points))\n}\t\n\ninit_filter <- function(x,varName){\n\t  threshold <- list() \n    threshold[\"DOsat\"] <- 130\n    threshold[\"DO\"] <- 18\n    threshold[\"Seabird_temperature\"] <- 40\n    threshold[\"Zdens\"] <- quantile(x,0.995,na.rm=T)\n    threshold[\"Zug\"] <- quantile(x,0.995,na.rm=T)\n\n    if(varName %in% names(threshold))\n      outlier <- (x>threshold[varName])\n    else\n      outlier <- rep(0,length(x))\n    return(outlier)\n}\n\nspatialOutlier <- function(spData,x_y_ratio,nbRange,threshold){\n\trequire(spdep)\n\tdistance_range <- range(spData$distance)\n\tdepth_range <- range(spData$depth)\n\n\txycoords <- cbind(spData$distance*x_y_ratio, spData$depth)\n\tnb <- dnearneigh(xycoords,0,nbRange)\n\n\thset <- c() # the distance to the median\n\toutlier <- rep(0,nrow(spData))\n\tavail <- outlier\n\tfor(i in 1:length(nb)){\n\t\tneighborPoints <- nb[[i]]\n\t\tif(length(neighborPoints)>10 & !is.na(spData[i,\"res\"])){\n\t\t\thset=c(hset,spData[i,\"res\"]-median(spData[neighborPoints,\"res\"],na.rm=TRUE))\n\t\t\tavail[i] <- 1\n\t\t}\n\t}\n\n\trobustmean <- median(hset,na.rm=T)\n\trobustsd <- sd(hset,na.rm=T)\n\thset <- (hset-robustmean)/robustsd # normalize \n\toutlier[avail==1] <- ifelse(abs(hset)>threshold,1,0)\n\treturn(outlier)\n}\n\n\ncal_density <- function(data){\n\t# data is a data frame that contains latitude,longitude, temperature, conductivity and pressure\n\trequire(oce)\n\tsalinity <- swSCTp(conductivity=data$conductivity/1000,temperature=data$temperature,pressure=data$pressure,\"mS/cm\")\n\tdensity <- swRho(salinity,data$temperature,data$pressure,longitude = data$longitude,latitude = data$latitude)\n\treturn(data.frame(salinity = salinity, density = density))\n}\n\n\n# preprocessing_old <- function(Triaxus){\n\n# \tTriaxus@rawData <- initProcess(Triaxus@rawData,config$rename)\n\t\n# \tBBE_name <- Triaxus@config$BBE_name\n# \tSeabird_name <- Triaxus@config$Seabird_name\n\n# \tgeoData <- Triaxus@rawData[,c(\"latitude\",\"longitude\",\"distance\",\"UTC\")]\n# \tSeabird_data <- Triaxus@rawData[,c(Seabird_name,\"Seabird_depth\")]\n# \tBBE_data <- Triaxus@rawData[,c(BBE_name,\"BBE_depth\")]\n# \tLOPC_data <- Triaxus@rawData[,Triaxus@config$LOPC_name]\n\n# \tif(length(Triaxus@Seabird_cutoff)==1){\n# \t\tTriaxus@Seabird_cutoff=1:nrow(Triaxus@rawData)\n# \t\tTriaxus@BBE_cutoff=1:nrow(Triaxus@rawData)\n# \t}\n\n# \t# Cut off \n# \tSeabird_data <- Seabird_data[Triaxus@Seabird_cutoff,]\n# \tgeoData <- geoData[Triaxus@Seabird_cutoff,]\n# \tBBE_data <- BBE_data[Triaxus@BBE_cutoff,]\n\n# \tTriaxus@cleanData <- cbind(geoData,Seabird_data,LOPC_data)\n# \tTriaxus@cleanData[,BBE_name] <- NA\n\n# \tBBE_data <- na.omit(BBE_data)\n\n# \tif(nrow(BBE_data)==0){\n# \t\t# no BBE data at all\n# \t\tSeabird_separation <- depth_separation(Seabird_data$Seabird_depth)\n# \t\tSeabird_nodes <- Seabird_separation[[2]]\n# \t\tTriaxus@numCycle <- floor((length(Seabird_nodes)-1)/2)\n# \t\tTriaxus@cleanData$depth <- Triaxus@cleanData$Seabird_depth\n# \t\tTriaxus@cleanData$direction <- Seabird_separation[[1]]\n# \t\treturn(Triaxus)\n# \t}\t\n\t\n# \tpng(\"alignmentCheck.png\")\n# \t\tplot(Seabird_data$Seabird_depth)\n# \t\tpoints(BBE_data$BBE_depth,col=\"blue\")\n# \tdev.off()\n\n# \t# data alignment\n# \tSeabird_separation <- depth_separation(Seabird_data$Seabird_depth)\n# \tBBE_separation <- depth_separation(BBE_data$BBE_depth)\n\n# \tSeabird_nodes <- Seabird_separation[[2]]\n# \tBBE_nodes <- BBE_separation[[2]]\n\n# \tif(length(Seabird_nodes)!=length(BBE_nodes)){\n# \t\twarning(\"two seperation not the same\")\n# \t\tstop(\"Can't allign,choose other cutoff parameter\")\n# \t}\n\n# \tif(Seabird_separation[[1]][Seabird_nodes[1]]!=BBE_separation[[1]][BBE_nodes[1]]){\n# \t\tstop(\"Can't allign,choose other cutoff parameter\")\n# \t}else{\n# \t\t# allign try to allign other parts\n# \t}\n\n# \tpreviousNode <- 1\n\t\n# \tfor(i in 2:length(Seabird_nodes)){\n# \t\tSeabird_DepthRange <- c(Seabird_nodes[previousNode]:Seabird_nodes[i])\n# \t\tBBE_DepthRange <- c(BBE_nodes[previousNode]:BBE_nodes[i])\n\t\t\n# \t\tsourceDepth <- BBE_data$BBE_depth[BBE_DepthRange]\n# \t\ttargetDepth <- Seabird_data$Seabird_depth[Seabird_DepthRange]\n\t\t\n# \t\tsourceDataSet <- BBE_data[BBE_DepthRange,BBE_name]\n# \t\tTriaxus@cleanData[Seabird_DepthRange,BBE_name] <- linearAlignment(targetDepth,sourceDepth,sourceDataSet)\n# \t\tpreviousNode <- previousNode+1\n# \t}\n\n# \tTriaxus@cleanData$depth <- Triaxus@cleanData$Seabird_depth\n# \tTriaxus@cleanData$direction <- Seabird_separation[[1]]\n\n# \tfinalStartNodes <- Seabird_nodes[2]\n# \tfinalEndNodes <- Seabird_nodes[length(Seabird_nodes)-1]\n\t\n# \tTriaxus@cleanData <- Triaxus@cleanData[finalStartNodes:finalEndNodes,]\n\n# \tTriaxus@numCycle <- floor((length(Seabird_nodes)-1)/2)\n\n# \tprint(summary(Triaxus@cleanData))\n# \treturn(Triaxus)\n# }",
    "created" : 1460497515218.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1858767167",
    "id" : "43DD2976",
    "lastKnownWriteTime" : 1460497840,
    "last_content_update" : 1460497840221,
    "path" : "~/Developer/Triaxus/TriaxusCode/./src/preprocessing.R",
    "project_path" : "./src/preprocessing.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}