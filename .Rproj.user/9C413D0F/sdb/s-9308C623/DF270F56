{
    "collab_server" : "",
    "contents" : "#### This is the main part for krig Interpolation, with following functions\n## 1: kriging Interpolation\n## 2: GA variogram fit\nrequire(\"GA\")\ninterpolation_main <- function(Triaxus,int_method,det_method=NULL){\n\tTriaxus@grid <- createGrid(\n\t\tx=Triaxus@cleanData$distance,\n\t\ty=Triaxus@cleanData$depth,\n\t\tdx=Triaxus@config$gridSize[1],\n\t\tdy=Triaxus@config$gridSize[2],\n\t\tlongitude=Triaxus@cleanData$longitude,\n\t\tlatitude=Triaxus@cleanData$latitude)\n\n\tTriaxus@resultData <- Triaxus@grid\n\n\t# maxdist <- ifelse(config$krigingRange/Triaxus@numCycle>0.15,config$krigingRange/Triaxus@numCycle,0.15)\n\tmaxdist <- 0.33\n\t# maxdist <- NULL\n\n\tif(Triaxus@seperate == FALSE){\n\t\tprint(\"no seperating\")\n\t\tfor(var in Triaxus@config$interestVar){\n\t\t\tplotid <- paste(Triaxus@pathName,var,sep=\"_\")\n\t\t\toutlierIndex <- init_filter(Triaxus@cleanData[,var],var)\n\t\t\tpred <- interpolation_sub(Triaxus@cleanData[outlierIndex<1,c(var,\"distance\",\"depth\")],Triaxus@grid,int_method,det_method,plotid = paste(plotid,\"_whole\",sep=\"\"),maxdist = maxdist)\n\t\t\tTriaxus@resultData[,var] <- ifelse(pred>0,pred,0)\n\t\t}\n\t}else{\n\t\tfor(var in Triaxus@config$interestVar){\n\t\t\tprint(var)\n\t\t\tplotid <- paste(Triaxus@pathName,var,sep=\"_\")\n\t  \t\toutlierIndex <- init_filter(Triaxus@cleanData[,var],var)\n\t    \tpred_down <- interpolation_sub(subset(Triaxus@cleanData[outlierIndex<1,],direction==-1)[,c(var,\"distance\",\"depth\")],Triaxus@grid,int_method,det_method,plotid = paste(plotid,\"_down\",sep=\"\"),maxdist = maxdist)\n\t    \tpred_up <- interpolation_sub(subset(Triaxus@cleanData[outlierIndex<1,],direction==1)[,c(var,\"distance\",\"depth\")],Triaxus@grid,int_method,det_method,plotid = paste(plotid,\"_up\",sep=\"\"),maxdist = maxdist)\n\t    \t\n\t    \t# pred <- apply(c(1:length(pred_down)),\n\t    \t# \tfunction(x){\n\t    \t# \t\tif(is.na(pred_down[i]))\n\t    \t# \t\t\treturn(pred_up*2)\n\n\t    \t# \t)\n\n\t    \tfinalPrediction <- (pred_down+pred_up)/2.0\n\t    \tTriaxus@resultData[,var] <- ifelse(finalPrediction>0,finalPrediction,0)\n\t\t}\n\t}\n\n\t# Triaxus@grid$available <- !as.logical(apply(is.na(Triaxus@resultData[,Triaxus@config$interestVar]),1,sum)) # update\n\treturn(Triaxus)\n}\n\n\ninterpolation_sub <- function(dataSet,grid,int_method,det_method,...){\n\tpred <- rep(NA,nrow(grid))\n    availableIndex <- grid$available\n    # print(list(...))\n    dataSet <- na.omit(dataSet)\n    if(nrow(dataSet)==0){\n    \tprint(\"no variable\")\n      return(pred)\n    }\n\n    if(int_method==\"tps\"){\n        pred[availableIndex] <- interpolation_tps(dataSet,grid[availableIndex,],...)\n        return(pred)\n    }\n\n    detrending_result <- detrending(dataSet,grid[availableIndex,],method=det_method)\n    dataSet$res <- detrending_result$res\n\n    outlierIndex <- spatialOutlier(dataSet,1,0.75,4)\n    print(paste(\"outlier Num:\",sum(outlierIndex)))\n    dataSet <- dataSet[outlierIndex<1,]\n\tif(int_method==\"krige\"){\n  \t\tpred_res <- interpolation_krig(dataSet,grid[availableIndex,],idw=FALSE,...)\n\t} \n\telse if(int_method==\"idw\"){\n  \t\tpred_res <- interpolation_krig(dataSet,grid[availableIndex,],idw=TRUE,...)\n\t}\n\telse{\n\t\tstop(\"wrong method\")\n\t}\n\n    pred[availableIndex] <- detrending_result$trendSurface+pred_res\n    return(pred)\n}\n\n\n\ncreateGrid <- function(x,y,dx,dy,longitude,latitude){\n    require(dismo)\n\t\txRange <- range(x)\n\t\tyRange <- range(y)\n\t\tstartDepth=yRange[1]-yRange[1]%%dy+dy\n\t\tgrid <- expand.grid(distance=seq(from=xRange[1],to=xRange[2],by=dx),\n\t\t\tdepth=seq(from=startDepth,to=yRange[2],by=dy))\n\n\t\tgrid$latitude <- approx(y=latitude,x,xout=grid$distance,rule=2)$y\n\t\tgrid$longitude <- approx(y=longitude,x,xout=grid$distance,rule=2)$y\n\n\t\t# do convex hull\n    convexHullModel<-convHull(data.frame(distance=x,depth=y))\n    grid$available <- as.logical(predict(convexHullModel,grid[,c(\"distance\",\"depth\")]))\n\t\treturn(grid)\n}\n\n\ninterpolation_tps<-function(spData,grid,...){\n  \trequire(fields)\n  \tsubSample <- seq(1,nrow(spData),by=1)\n  \ttpsModel <- Tps(spData[subSample,c(\"distance\",\"depth\")],spData[subSample,1])\n  \t# print(summary(tpsModel))\n  \tprint(\"error\")\n  \tprint(max(tpsModel$residuals/spData[subSample,1]))\n  \t\n  \tpred <- predict(tpsModel,grid[,c(\"distance\",\"depth\")])\n\n  \tplotid <- list(...)$plotid\n  \tpdf(file=paste(\"~/Developer/Triaxus/output/meta/\",plotid,\"_tpsInt.pdf\",sep=\"\"))\n  \t# qplot(distance,depth,data=spData[subSample,],color=pred)\n  \tprint(qplot(distance,depth,data=spData[subSample,],color=spData[subSample,1]))\n\tprint(qplot(distance,depth,data=spData[subSample,],color=tpsModel$residuals)+scale_colour_gradient2(low=\"red\",high=\"blue\",mid=\"white\",midpoint=0))\n  \tprint(qplot(distance,depth,data=spData[subSample,],color=tpsModel$residuals/spData[subSample,1])+scale_colour_gradient2(low=\"red\",high=\"blue\",mid=\"white\",midpoint=0))\n  \tdev.off()\n  \treturn(pred)\n}\n\n\ninterpolation_krig <- function(spData,grid,idw,...){\n\trequire(gstat)\n \tvar_name <- names(spData)[1]\n \tprint(range(spData$distance))\n\n \tscaleSetting <- scaleFactor(spData$distance,spData$depth)\n    scaledCoord <- applyScale(grid$distance,grid$depth,scaleSetting)\n    grid$scaled_x <- scaledCoord$sx\n    grid$scaled_y <- scaledCoord$sy\n    \n    scaledCoord <- applyScale(spData$distance,spData$depth,scaleSetting)\n    spData$scaled_distance <- scaledCoord$sx\n    spData$scaled_depth <- scaledCoord$sy\n\n    coordinates(spData)=~scaled_distance+scaled_depth\n    # coordinates(grid)=~scaled_x+scaled_y\n \t\n \tspData=remove.duplicates(spData,zero=0.005,remove.second=TRUE) \t# remove too near points\n \tvar_formu=as.formula(paste(\"res\",\"~1\"))\n \t# print(list(...)$maxdist)\n \tif(idw==TRUE){\n \t    model_gstat=gstat(NULL,id=var_name,formula=var_formu,data=spData,maxdist=list(...)$maxdist,nmax = 100,nmin = 20)\n \t}else{\n \t    model_gstat=gstat(NULL,id=var_name,formula=var_formu,data=spData,maxdist=list(...)$maxdist,nmax = 100, nmin = 20)\n\n\t\tvgmFitting=variogram_fitting(model_gstat,list(...)$plotid)\n\t\tmodel_gstat$data[[1]]$data@coords[,2] <- model_gstat$data[[1]]$data@coords[,2]*vgmFitting[[2]]\n\t\tgrid$scaled_y <- grid$scaled_y*vgmFitting[[2]]\n\t\tmodel_gstat<-gstat(model_gstat,id=var_name,model=vgmFitting[[1]])\n\t}\n \t coordinates(grid)=~scaled_x+scaled_y\n \t # print(grid)\n \t pred<-predict(model_gstat,grid,debug.level=-1)\t\n \t return(pred[[1]])\n}\n\n\nvariogram_fitting <- function(g,plotid){\n\tvar_name <- names(g$data)[[1]]\n\tlocalRange <- g$data[[1]]$maxdist\n\tprint(paste(\"localRange:\",localRange))\n\tg0 <- g\n\tY0=g0$data[[1]]$data@coords[,2];\n\t\n\toptimFunc <- function(K,g){\n\t\tg$data[[1]]$data@coords[,2] <- Y0*K\n\t\tv <- variogram(g,cressie=T,alpha=c(0,90),cutoff=localRange,width=localRange/15)\n\t\tv_0 <- subset(v,dir.hor == 0 & np>10)\n\t\tv_90 <- subset(v,dir.hor == 90 & np>10)\n\t\t# v_0 <- subset(v,dir.hor == 0)\n\t\t# v_90 <- subset(v,dir.hor == 90)\n\n\t\tif(nrow(v_0)<1 | nrow(v_90)<1)\n\t\t\treturn(Inf)\n\t\t# print(v)\n\t\t# v_0_model <- fit.variogram(v_0,vgm(NA,\"Exp\",NA,v_0$gamma[1]),fit.method=7)\n\t\tv_0_model <- fit.variogram(v_0,vgm(NA,\"Gau\",NA,v_0$gamma[1]),fit.method=7)\n\n\t\t# v_90_model <- fit.variogram(v_90,vgm(NA,\"Exp\",NA,v_0$gamma[1]),fit.method=7)\n\t\tv_90_model <- fit.variogram(v_90,vgm(NA,\"Gau\",NA,v_0$gamma[1]),fit.method=7)\n\t\t# if(v_0_model$range[2]<0 | v_90_model$range[2]<0)\n\t\t\t# return(Inf)\n\t\t# v_model <- fit.variogram(v_90,vgm(NA,\"Gau\",NA,v$gamma[1]),fit.method=7)\n\t\t# a <- max((variogramLine(v_model,dist_vector = v_0$dist)$gamma - v_0$gamma)^2)+max((variogramLine(v_model,dist_vector = v_90$dist)$gamma - v_90$gamma)^2)\n\t\t\n\t\tif( (v_0_model$range[2])<0 | (v_90_model$range[2])<0){\n\t\t\tprint(\"bad WLS fit, switch to OLS\")\n\t\t\t# print(K)\n\t\t\t# print(v_0)\n\t\t\t# print(v_90)\n\t\t\tv_0_model <- fit.variogram(v_0,vgm(NA,\"Gau\",NA,v_0$gamma[1]),fit.method=0)\n\t\t\tv_90_model <- fit.variogram(v_90,vgm(NA,\"Gau\",NA,v_0$gamma[1]),fit.method=0)\n\t\t}\n\n\t\ta <- mean((variogramLine(v_0_model, dist_vector = v_0$dist)$gamma-variogramLine(v_90_model, dist_vector = v_0$dist)$gamma)^2)\n\t\t# print(a)\n\t\t# v_0_model_gau2 <- fit.variogram(v_0,vgm(max(v$gamma)*2,\"Gau\",localRange*2,v_0$gamma[1]),fit.method=7)\n\t\t# v_90_model_gau2 <- fit.variogram(v_90,vgm(max(v$gamma)*2,\"Gau\",localRange*2,v_0$gamma[1]),fit.method=7)\n\n\n\t\t# a <- abs(sum(v_0_model$psill)/sum(v_90_model$psill)-1)+abs(v_0_model$range[2]/v_90_model$range[2]-1)+abs(v_0_model$psill[1]/v_90_model$psill[1]-1)\n\t\t# b = abs(sum(v_0_model_exp$psill)/sum(v_90_model_exp$psill)-1)+abs(v_0_model_exp$range[2]/v_90_model_exp$range[2]-1)+abs(v_0_model_exp$psill[1]/v_90_model_exp$psill[1]-1)\n\t\t# a2 <- abs(sum(v_0_model_gau2$psill)/sum(v_90_model_gau2$psill)-1)+abs(v_0_model_gau2$range[2]/v_90_model_gau2$range[2]-1)+abs(v_0_model_gau2$psill[1]/v_90_model_gau2$psill[1]-1)\n\t\t# return(min(a,a2))\n\t\t# a <- a*(1+(K-1)/4)\n\t\treturn(a)\n\t}\n\n\t# miniError=c()\n\t# for(K in seq(1,5,0.2)){\n\t\t# print(K)\n\t\t# miniError=c(miniError,optimFunc(K,g))\n\t# }\n\t# optimK <- seq(0.2,5,0.2)[which.min(miniError)]\n\t\n\t# optimK <- optim(1, optimFunc,gr=NULL,g0,\n #      method = c(\"Nelder-Mead\"),\n #      lower = 0.2, upper = 10,\n #      control = list(ndeps=0.5), \n #      hessian = FALSE)$par[1]\n\t# for(i in ){\n\t\t# g$data[[1]]$data@coords[,2] <- Y0*K\n\t\t# v <- variogram(g,cressie=T,alpha=c(0,90),cutoff=localRange,width=localRange/15)\n\t\t# v_0 <- subset(v,dir.hor == 0)\n\t\t# v_90 <- subset(v,dir.hor == 90)\n\t\t# if(v_0)\n\t# }\n\n\toptimK <- optimize(optimFunc,config$K,g=g0,tol = 0.1)$minimum[1]\n\t# GA works also good maybe\n\t# optimK <- ga(type = \"real-valued\",fitness = function(x,g) -optimFunc(x,g0), g=g,min = c(1),max = c(5),popSize = 20,maxiter = 10)@solution[1]\n\t# K_optins <- seq(1,6,0.2)\n\t# optimK <- K_optins[which.min(sapply(K_optins,optimFunc,g=g0))]\n\n\n\tprint(paste(\"bestK:\",optimK))\n\t# print(optimK_normal)\n\tprint(\"optim Finish\")\n\tg0$data[[1]]$data@coords[,2] <- Y0*optimK\n\t\n\tv <- variogram(g0,cressie=T,cutoff=localRange,width=localRange/15)\n\t# v_model<- fit.variogram(v,vgm(NA,\"Exp\",NA,v$gamma[1]),fit.method=7)\n\tv_model<- fit.variogram(v,vgm(NA,\"Gau\",NA,v$gamma[1]),fit.method=7)\n\n\n\tif(v_model$range[2]<0){\n\t\tv_model$range[2] <- 0.02\n\t}\n\t# v_model_gau2 <- fit.variogram(v,vgm(max(v$gamma)*2,\"Gau\",localRange,v$gamma[1]),fit.method=7)\n\t\n  \n  \t# v_model_gau_err <- attr(v_model_gau,\"SSErr\")\n  \t# v_model_exp_err <- attr(v_model_exp,\"SSErr\")\n  \t# v_model_gau_err2 <- attr(v_model_gau2,\"SSErr\")\n\n  \tv_4direction <- variogram(g0,cressie=T,alpha=c(0,45,90,135),cutoff=localRange,width=localRange/15)\n\tv_2direction <- variogram(g0,cressie=T,alpha=c(0,90),cutoff=localRange,width=localRange/15)\n\n\t\n\tv_0 <- subset(v_2direction,dir.hor == 0)\n\tv_90 <- subset(v_2direction,dir.hor == 90)\n\n\t# print(v_model_gau_err)\n\t# print(v_model_exp)\n\t# if(v_model_gau_err>v_model_exp_err){\n\t# \tv_model <- v_model_exp\n\t# }else{\n\t# \tv_model <- v_model_gau\n\t# }\n\t# # v_model <- ifelse(v_model_gau_err>v_model_exp_err,v_model_exp,v_model_gau) # This will raise warnings, don't write like this\n\t# bestModel <- ifelse(v_model_gau_err>v_model_gau_err2,\"Exp\",\"Gau\")\n\n\t# v_model <- v_model_gau\n\tbestModel <- \"Gau\"\n\n\t#pdf(file=paste(\"~/Developer/Triaxus/output/variogram/\",plotid,\"_krig_meta.pdf\",sep=\"\"))\n  #  par(mfrow=c(2,2))\n  #  print(plot(v_4direction,v_model,main=paste(\"4 Direction Variogram in Kriging Range\"),pl=T))\n  #  print(plot(v_2direction,v_model,main=paste(\"2 Direction Variogram in Kriging Range gau\"),pl=T))\n    # print(plot(v_2direction,v_model_gau2,main=paste(\"2 Direction Variogram in Kriging Range gau2\"),pl=T))\n\n  #  print(plot(v,v_model,main=paste(\"omnidirection Variogram in kriging range, model=\",bestModel),pl=T))\n\n    # print(plot(v_0,v_0_model_sph,main=paste(\"horizon fit individually\"),pl=T))\n    # print(plot(v_90,v_90_model_sph,main=paste(\"vertical fit individually\"),pl=T))\n\n  #  print(qplot(g0$data[[1]]$data@coords[,1],-g0$data[[1]]$data@coords[,2],colour=g$data[[1]]$data$res)+scale_colour_gradient2(low=\"red\",high=\"blue\",mid=\"white\",midpoint=0,name=\"Residuals\")+xlab(\"Adjusted Distance\")+ylab(paste(\"Adjusted depth\",\"Ratio:\",optimK))+coord_fixed())\n  #\tdev.off()\n  # print(optimK)\n\treturn(list(v_model,optimK))\n}\n\n\ndetrending <- function(dataSet,grid,method){\n  require(fields,,quietly = TRUE)\n  # print(head(dataSet))\n  var_name=names(dataSet)[1]\n  num=nrow(grid)\n  # print(paste(\"Detrending on\",var_name,\" ,using\",type))\n\n  if(method==\"none\"){\n      return(list(trendSurface=rep(0,num),res=dataSet[,1]))\n  }\n\n  if(method==\"tps\"){\n      index=seq(from = 1, to = nrow(dataSet), by = 2)\n      trend_model=Tps(dataSet[index,c(\"distance\",\"depth\")],dataSet[index,1],df=config$tpsDf)\n      pred_orig=predict(trend_model,dataSet[,c(\"distance\",\"depth\")])\n  }\n  else if(method==\"linear\"){\n      var_formu=as.formula(paste(var_name,\"~distance+depth\"))\n      trend_model=loess(var_formu,data=dataSet,span=0.25)\n      pred_orig=predict(trend_model,dataSet[,2:3])\n  }\n\n  trendSurface=predict(trend_model,grid[,c(\"distance\",\"depth\")])\n  # print(trendSurface)\n  res=dataSet[,1]-pred_orig\n  return(list(trendSurface=c(trendSurface),res=res))\n}\n\n\n\n\n# interpolation_idw <- function(spData,grid){\n#   # grid is the grid\n#   # spData is the raw data, with first variable as the interest\n#   require(gstat)\n#   scaleSetting <- scaleFactor(spData$distance,spData$depth)\n#   scaledCoord <- applyScale(grid$distance,grid$depth,scaleSetting)\n#   grid$scaled_x <- scaledCoord$sx\n#   grid$scaled_y <- scaledCoord$sy\n  \n#   scaledCoord <- applyScale(spData$distance,spData$depth,scaleSetting)\n#   spData$scaled_distance0 <- scaledCoord$sx\n#   spData$scaled_depth <- scaledCoord$sy\n\n#   coordinates(spData)=~scaled_distance+scaled_depth\n#   coordinates(grid)=~scaled_x+scaled_y\n\n#   var_name <- names(spData)[1]\n#   formu <- as.formula(paste(var_name,\"~1\",sep=\"\"))\n#   pred <- idw(formu, spData, grid)\n\n# }\n\n",
    "created" : 1460504586382.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3575717626",
    "id" : "DF270F56",
    "lastKnownWriteTime" : 1461030560,
    "last_content_update" : 1461030560,
    "path" : "~/Developer/Triaxus/TriaxusCode/./src/interpolation.R",
    "project_path" : "./src/interpolation.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}